module BigStep where

open import Data.Empty using (âŠ¥; âŠ¥-elim)
open import Data.Unit using (âŠ¤; tt)
open import Data.Product using (Î£; âˆƒ; Î£-syntax; âˆƒ-syntax; _Ã—_; projâ‚; projâ‚‚) renaming (_,_ to âŸ¨_,_âŸ©)
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_â‰¡_; refl; sym; cong; congâ‚‚)
open import Statics


-- we first define substitution
-- extension lemma
ext : âˆ€ {Î“ Î”}
  â†’ (âˆ€ {A} â†’       Î“ âˆ‹ A â†’     Î” âˆ‹ A)
    ---------------------------------
  â†’ (âˆ€ {A B} â†’ Î“ , B âˆ‹ A â†’ Î” , B âˆ‹ A)
ext Ï Z      =  Z
ext Ï (S x)  =  S (Ï x)

-- renaming
rename : âˆ€ {Î“ Î”}
  â†’ (âˆ€ {A} â†’ Î“ âˆ‹ A â†’ Î” âˆ‹ A)
    -----------------------
  â†’ (âˆ€ {A} â†’ Î“ âŠ¢â‚‘ A â†’ Î” âŠ¢â‚‘ A)
rename Ï (` x)                  =  ` (Ï x)
rename Ï (val (Æ› N / ğ“))        =  val ( Æ› (rename (ext Ï) N) / ğ“ )
rename Ï (val (`true/ ğ“))       =  val (`true/ ğ“)
rename Ï (val (`false/ ğ“))      =  val (`false/ ğ“)
rename Ï (L Â· M)                =  (rename Ï L) Â· (rename Ï M)
rename Ï (if L M N)             =  if (rename Ï L) (rename Ï M) (rename Ï N)
rename Ï (M `âˆ§ N)               =  (rename Ï M) `âˆ§ (rename Ï N)
rename Ï (M `âˆ¨ N)               =  (rename Ï M) `âˆ¨ (rename Ï N)
rename Ï (sub M âŠ¢â‰¤)             =  sub (rename Ï M) âŠ¢â‰¤

-- extension (in terms of well-formedness)
exts : âˆ€ {Î“ Î”}
  â†’ (âˆ€ {A} â†’       Î“ âˆ‹ A â†’     Î” âŠ¢â‚‘ A)
    ---------------------------------
  â†’ (âˆ€ {A B} â†’ Î“ , B âˆ‹ A â†’ Î” , B âŠ¢â‚‘ A)
exts Ïƒ Z      =  ` Z
exts Ïƒ (S x)  =  rename S_ (Ïƒ x)

-- substitution
subst : âˆ€ {Î“ Î”}
  â†’ (âˆ€ {A} â†’ Î“ âˆ‹ A â†’ Î” âŠ¢â‚‘ A)
    -----------------------
  â†’ (âˆ€ {A} â†’ Î“ âŠ¢â‚‘ A â†’ Î” âŠ¢â‚‘ A)
subst Ïƒ (` k)          =  Ïƒ k
subst Ïƒ (val (Æ› N / ğ“))      =  val (Æ› (subst (exts Ïƒ) N) / ğ“)
subst Ïƒ (val (`true/ ğ“))     =  val (`true/ ğ“)
subst Ïƒ (val (`false/ ğ“))    =  val (`false/ ğ“)
subst Ïƒ (L Â· M)              =  (subst Ïƒ L) Â· (subst Ïƒ M)
subst Ïƒ (if L M N)           =  if (subst Ïƒ L) (subst Ïƒ M) (subst Ïƒ N)
subst Ïƒ (M `âˆ§ N)             =  (subst Ïƒ M) `âˆ§ (subst Ïƒ N)
subst Ïƒ (M `âˆ¨ N)             =  (subst Ïƒ M) `âˆ¨ (subst Ïƒ N)
subst Ïƒ (sub M âŠ¢â‰¤)           =  sub (subst Ïƒ M) âŠ¢â‰¤

_[_] : âˆ€ {Î“ A B}
        â†’ Î“ , B âŠ¢â‚‘ A
        â†’ Î“ âŠ¢â‚‘ B
          ---------
        â†’ Î“ âŠ¢â‚‘ A
_[_] {Î“} {A} {B} N M =  subst {Î“ , B} {Î“} Ïƒ {A} N
  where
  Ïƒ : âˆ€ {A} â†’ Î“ , B âˆ‹ A â†’ Î“ âŠ¢â‚‘ A
  Ïƒ Z      =  M
  Ïƒ (S x)  =  ` x

_âŸ¦âˆ§âŸ§_ : âˆ€ {ğ“â‚˜ ğ“â‚™}
      â†’ (M : âˆ… âŠ¢áµ¥ `ğ”¹ / ğ“â‚˜)
      â†’ (N : âˆ… âŠ¢áµ¥ `ğ”¹ / ğ“â‚™)
        -----------------------
      â†’ âˆ… âŠ¢áµ¥ `ğ”¹ / (ğ“â‚˜ âŠ” ğ“â‚™)
_âŸ¦âˆ§âŸ§_ {ğ“â‚˜} {ğ“â‚™} (`true/ ğ“â‚˜)  (`true/ ğ“â‚™)   = `true/  (ğ“â‚˜ âŠ” ğ“â‚™)
_âŸ¦âˆ§âŸ§_ {ğ“â‚˜} {ğ“â‚™} (`true/ ğ“â‚˜)  (`false/ ğ“â‚™)  = `false/ (ğ“â‚˜ âŠ” ğ“â‚™)
_âŸ¦âˆ§âŸ§_ {ğ“â‚˜} {ğ“â‚™} (`false/ ğ“â‚˜) (`true/ ğ“â‚™)   = `false/ (ğ“â‚˜ âŠ” ğ“â‚™)
_âŸ¦âˆ§âŸ§_ {ğ“â‚˜} {ğ“â‚™} (`false/ ğ“â‚˜) (`false/ ğ“â‚™)  = `false/ (ğ“â‚˜ âŠ” ğ“â‚™)

_âŸ¦âˆ¨âŸ§_ : âˆ€ {ğ“â‚˜ ğ“â‚™}
      â†’ (M : âˆ… âŠ¢áµ¥ `ğ”¹ / ğ“â‚˜)
      â†’ (N : âˆ… âŠ¢áµ¥ `ğ”¹ / ğ“â‚™)
        -----------------------
      â†’ âˆ… âŠ¢áµ¥ `ğ”¹ / (ğ“â‚˜ âŠ” ğ“â‚™)
_âŸ¦âˆ¨âŸ§_ {ğ“â‚˜} {ğ“â‚™} (`true/ ğ“â‚˜)  (`true/ ğ“â‚™)   = `true/  (ğ“â‚˜ âŠ” ğ“â‚™)
_âŸ¦âˆ¨âŸ§_ {ğ“â‚˜} {ğ“â‚™} (`true/ ğ“â‚˜)  (`false/ ğ“â‚™)  = `true/  (ğ“â‚˜ âŠ” ğ“â‚™)
_âŸ¦âˆ¨âŸ§_ {ğ“â‚˜} {ğ“â‚™} (`false/ ğ“â‚˜) (`true/ ğ“â‚™)   = `true/  (ğ“â‚˜ âŠ” ğ“â‚™)
_âŸ¦âˆ¨âŸ§_ {ğ“â‚˜} {ğ“â‚™} (`false/ ğ“â‚˜) (`false/ ğ“â‚™)  = `false/ (ğ“â‚˜ âŠ” ğ“â‚™)


data _â‡“_ : âˆ€ {A} â†’ âˆ… âŠ¢â‚‘ A â†’ âˆ… âŠ¢áµ¥ A â†’ Set where -- only run on closed terms

  -- v â‡“ v
  â‡“-val : âˆ€ {A} {V : âˆ… âŠ¢áµ¥ A}
        --------------
        â†’ (val V) â‡“ V  -- simply get rid of the `val`

  -- binops
  â‡“-âˆ§ : âˆ€ {ğ“â‚˜ ğ“â‚™ Vâ‚˜ Vâ‚™} {M : âˆ… âŠ¢â‚‘ `ğ”¹ / ğ“â‚˜} {N : âˆ… âŠ¢â‚‘ `ğ”¹ / ğ“â‚™}
      â†’ M â‡“ Vâ‚˜
      â†’ N â‡“ Vâ‚™
        ------------------------
      â†’ (M `âˆ§ N) â‡“ (Vâ‚˜ âŸ¦âˆ§âŸ§ Vâ‚™)

  â‡“-âˆ¨ : âˆ€ {ğ“â‚˜ ğ“â‚™ Vâ‚˜ Vâ‚™} {M : âˆ… âŠ¢â‚‘ `ğ”¹ / ğ“â‚˜} {N : âˆ… âŠ¢â‚‘ `ğ”¹ / ğ“â‚™}
      â†’ M â‡“ Vâ‚˜
      â†’ N â‡“ Vâ‚™
        ------------------------
      â†’ (M `âˆ¨ N) â‡“ (Vâ‚˜ âŸ¦âˆ¨âŸ§ Vâ‚™)

  â‡“-condâ‚ : âˆ€ {t ğ“â‚— ğ“ Vâ‚˜} {L : âˆ… âŠ¢â‚‘ `ğ”¹ / ğ“â‚—} {M : âˆ… âŠ¢â‚‘ t / (ğ“ âŠ” ğ“â‚—)} {N : âˆ… âŠ¢â‚‘ t / (ğ“ âŠ” ğ“â‚—)}
      â†’ L â‡“ (`true/ ğ“â‚—)
      â†’ M â‡“ Vâ‚˜
        ------------------------
      â†’ if L M N â‡“ Vâ‚˜  -- note that `Vâ‚˜` already inhebits type `A âŠ”â‚› ğ“â‚—`

  â‡“-condâ‚‚ : âˆ€ {t ğ“â‚— ğ“ Vâ‚™} {L : âˆ… âŠ¢â‚‘ `ğ”¹ / ğ“â‚—} {M : âˆ… âŠ¢â‚‘ t / (ğ“ âŠ” ğ“â‚—)} {N : âˆ… âŠ¢â‚‘ t / (ğ“ âŠ” ğ“â‚—)}
      â†’ L â‡“ (`false/ ğ“â‚—)
      â†’ N â‡“ Vâ‚™
        ------------------------
      â†’ if L M N â‡“ Vâ‚™  -- note that `Vâ‚™` already inhebits type `A âŠ”â‚› ğ“â‚—`

  â‡“-app : âˆ€ {tâ‚ tâ‚‚ ğ“â‚ ğ“â‚‚ ğ“ Vâ‚™ V Mâ€²} {M : âˆ… âŠ¢â‚‘ ((tâ‚ / ğ“â‚) â‡’ (tâ‚‚ / ğ“â‚‚)) / ğ“} {N : âˆ… âŠ¢â‚‘ tâ‚ / ğ“â‚}
      â†’ M â‡“ (Æ› Mâ€² / ğ“)
      â†’ N â‡“ Vâ‚™
      â†’ (Mâ€² [ (val Vâ‚™) ]) â‡“ V
        ------------------------
      â†’ (M Â· N) â‡“ (V âŠ”áµ¥ ğ“)



_/_â¦‚_â‰ˆáµ¥â¦…_â¦†_ : (t : ğ•‹) â†’ (ğ“ : â„’) â†’ (vâ‚ : âˆ… âŠ¢áµ¥ (t / ğ“)) â†’ (Î¶ : â„’) â†’ (vâ‚‚ : âˆ… âŠ¢áµ¥ (t / ğ“)) â†’ Set
_/_â¦‚_â‰ˆâ‚‘â¦…_â¦†_ : (t : ğ•‹) â†’ (ğ“ : â„’) â†’ (eâ‚ : âˆ… âŠ¢â‚‘ (t / ğ“)) â†’ (Î¶ : â„’) â†’ (eâ‚‚ : âˆ… âŠ¢â‚‘ (t / ğ“)) â†’ Set

`ğ”¹ / ğ“ â¦‚ vâ‚ â‰ˆáµ¥â¦… Î¶ â¦† vâ‚‚ = ğ“ âŠ‘ Î¶ â†’ vâ‚ â‰¡ vâ‚‚
((tâ‚ / ğ“â‚) â‡’ (tâ‚‚ / ğ“â‚‚)) / ğ“ â¦‚ vâ‚ â‰ˆáµ¥â¦… Î¶ â¦† vâ‚‚ =
    ğ“ âŠ‘ Î¶
  â†’ (âˆ€ {vâ‚â€² vâ‚‚â€²}
       â†’ tâ‚ / ğ“â‚ â¦‚ vâ‚â€² â‰ˆáµ¥â¦… Î¶ â¦† vâ‚‚â€²
       â†’ tâ‚‚ / ğ“â‚‚ âŠ” ğ“ â¦‚ ((val vâ‚) Â· (val vâ‚â€²)) â‰ˆâ‚‘â¦… Î¶ â¦† ((val vâ‚‚) Â· (val vâ‚‚â€²)))

t / ğ“ â¦‚ eâ‚ â‰ˆâ‚‘â¦… Î¶ â¦† eâ‚‚ =
  (âˆ€ {vâ‚ vâ‚‚}
    â†’ eâ‚ â‡“ vâ‚
    â†’ eâ‚‚ â‡“ vâ‚‚
    â†’ t / ğ“ â¦‚ vâ‚ â‰ˆáµ¥â¦… Î¶ â¦† vâ‚‚)


-- fundamental property
-- first we define related substitutions under a typing context Î“
_âŠ¢_â‰ˆâ‚›â¦…_â¦†_ : âˆ€ Î“ â†’ (âˆ€ {A} â†’ Î“ âˆ‹ A â†’ âˆ… âŠ¢â‚‘ A) â†’ â„’ â†’ (âˆ€ {A} â†’ Î“ âˆ‹ A â†’ âˆ… âŠ¢â‚‘ A) â†’ Set
Î“ âŠ¢ Ïƒâ‚ â‰ˆâ‚›â¦… Î¶ â¦† Ïƒâ‚‚ = âˆ€ {t ğ“} {x : Î“ âˆ‹ (t / ğ“)} â†’ t / ğ“ â¦‚ (Ïƒâ‚ x) â‰ˆâ‚‘â¦… Î¶ â¦† (Ïƒâ‚‚ x)

â‡“â‰¡ : âˆ€ {s v vâ‚ vâ‚‚} â†’ (_â‡“_ {s} (val v) vâ‚) â†’ (_â‡“_ {s} (val v) vâ‚‚) â†’ vâ‚ â‰¡ vâ‚‚
â‡“â‰¡ â‡“-val â‡“-val = refl

-- If Î“ âŠ¢ e : s and Î“ âŠ¢ Ïƒâ‚ â‰ˆÎ¶ Ïƒâ‚‚ then Ïƒâ‚(e) â‰ˆÎ¶ Ïƒâ‚‚(e) : s
fundamental : âˆ€ {Î“ t ğ“ Î¶}
  â†’ (Ïƒâ‚ : (âˆ€ {A} â†’ Î“ âˆ‹ A â†’ âˆ… âŠ¢â‚‘ A))
  â†’ (Ïƒâ‚‚ : (âˆ€ {A} â†’ Î“ âˆ‹ A â†’ âˆ… âŠ¢â‚‘ A))
  â†’ (e : Î“ âŠ¢â‚‘ t / ğ“)
  â†’ Î“ âŠ¢ Ïƒâ‚ â‰ˆâ‚›â¦… Î¶ â¦† Ïƒâ‚‚
    -----------------------------------------------
  â†’ t / ğ“ â¦‚ (subst Ïƒâ‚ e) â‰ˆâ‚‘â¦… Î¶ â¦† (subst Ïƒâ‚‚ e)
fundamental Ïƒâ‚ Ïƒâ‚‚ (` x) Ïƒâ‚â‰ˆÏƒâ‚‚ = Ïƒâ‚â‰ˆÏƒâ‚‚
fundamental Ïƒâ‚ Ïƒâ‚‚ (val v) Ïƒâ‚â‰ˆÏƒâ‚‚ with v
... | `true/ ğ“ = Î» â‡“vâ‚ â‡“vâ‚‚ ğ“âŠ‘Î¶ â†’ â‡“â‰¡ â‡“vâ‚ â‡“vâ‚‚
... | `false/ ğ“ = Î» â‡“vâ‚ â‡“vâ‚‚ ğ“âŠ‘Î¶ â†’ â‡“â‰¡ â‡“vâ‚ â‡“vâ‚‚
... | Æ› N / ğ“ = Î» â‡“vâ‚ â‡“vâ‚‚ â†’ {!!}
fundamental Ïƒâ‚ Ïƒâ‚‚ (e `âˆ§ eâ‚) Ïƒâ‚â‰ˆÏƒâ‚‚ = {!!}
fundamental Ïƒâ‚ Ïƒâ‚‚ (e `âˆ¨ eâ‚) Ïƒâ‚â‰ˆÏƒâ‚‚ = {!!}
fundamental Ïƒâ‚ Ïƒâ‚‚ (e Â· eâ‚) Ïƒâ‚â‰ˆÏƒâ‚‚ = {!!}
fundamental Ïƒâ‚ Ïƒâ‚‚ (if e eâ‚ eâ‚‚) Ïƒâ‚â‰ˆÏƒâ‚‚ = {!!}
fundamental Ïƒâ‚ Ïƒâ‚‚ (sub e x) Ïƒâ‚â‰ˆÏƒâ‚‚ = {!!}


record _â‡”_ (A B : Set) : Set where
  field
    to   : A â†’ B
    from : B â†’ A

-- properties
-- non-interference of Î»-sec
-- non-interference : âˆ€ {t V}
--   â†’ (M : âˆ… , (t / ğ») âŠ¢â‚‘ `ğ”¹ / ğ¿)
--   â†’ (Vâ‚ : âˆ… âŠ¢áµ¥ (t / ğ»))
--   â†’ (Vâ‚‚ : âˆ… âŠ¢áµ¥ (t / ğ»))
--     -----------------------------------------------
--   â†’ ((M [ (val Vâ‚) ]) â‡“ V) â‡” ((M [ (val Vâ‚‚) ]) â‡“ V)
-- non-interference {t} {V} M Vâ‚ Vâ‚‚ = record { to = {!!} ; from = {!!} }
