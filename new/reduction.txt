M, N        terms
V           values
a           memory address
μ           heap
Σ           heap typing context
ℓ, pc       static labels
g, gc       gradual labels
p, q        blame labels

+---------------------------------------+
∥    M | μ | Σ ⊢ μ | pc —→ M′ | μ′    ∥
+---------------------------------------+

tag    ∈  {dyn, static}
e      ∈  {nsu-error, blame}
Frame ::= □ · M | V · □
        | ref [ ℓ ] □ # tag | ! □ | □ := M # tag | V := □ # tag
        | if □ M N
        | □ ⟨ A ⇒ B @ p ⟩

         M | μ | ⊢μ | pc —→ M′ | μ′
------------------------------------------------------- ξ
  plug M F | μ | ⊢μ | pc —→ plug M′ F | μ′

------------------------------------------------------- ξ-Error
  plug (error e) F | μ | ⊢μ pc —→ error e

                       Value V
-------------------------------------------------------- ProtectVal
  prot[ ℓ ] V | μ | ⊢μ | pc —→ stamp V ℓ | μ

        M | μ | ⊢μ | pc ⊔ ℓ —→ M′ | μ′
----------------------------------------------------------- ProtectContext
  prot[ ℓ ] M | μ | ⊢μ | pc —→ prot[ ℓ ] M′ | μ′

                                     Value V
------------------------------------------------------------------------------------ β
  (λ[ pc′ ] A ˙ N of ℓ) · V ∣ μ | ⊢μ ∣ pc —→ prot[ ℓ ] (N [ V ]) ∣ μ

gc ⋎ ℓ ⊢ N : B
gc ⊢ λ[ pc′ ] A ˙ N of ℓ : ([ gc ⋎̃ ℓ ] A ⇒ B) of ℓ
gc ⊢ V : A

                         Value V    Fresh a
------------------------------------------------------------------ Ref
  ref[ ℓ ] V # static | μ | ⊢μ | pc —→ a of low | a ↦ V ∷ μ

Note: how static checks supersede dynamic ones in a fully static program
static-pc ≼ ℓ              where ℓ is the privilege level of the memory cell
dyn-pc ≼ static-pc
dyn-pc ≼ ℓ

                         Value V    pc ≼ ℓ
----------------------------------------------------------------- RefNSU
  ref[ ℓ ] V # dyn | μ | ⊢μ | pc —→ a of low | a ↦ V ∷ μ

                         Value V    pc ⋠ ℓ
----------------------------------------------------------------- RefNSUFail
  ref[ ℓ ] V # dyn | μ | ⊢μ | pc —→ error nsu-error

                         Value V
----------------------------------------------------------------- Assign
  a of ℓ := V # static | μ | ⊢μ | pc —→ unit of low | a ↦ V ∷ μ

            Value V    lookup a Σ ≡ T of ℓ₁    pc ⊔ ℓ ≼ ℓ₁
---------------------------------------------------------------------------- AssignNSU
  a of ℓ := V # static | μ | Σ ⊢ μ | pc —→ unit of low | a ↦ V ∷ μ

            Value V    lookup a Σ ≡ T of ℓ₁    pc ⊔ ℓ ⋠ ℓ₁
---------------------------------------------------------------------------- AssignNSUFail
  a of ℓ := V # static | μ | Σ ⊢ μ | pc —→ error nsu-error

         lookup a μ ≡ V
------------------------------- Deref
  ! (a of ℓ) —→ prot[ ℓ ] V

-------------------------------------------------------------------- IfTrue
  if (true of ℓ) then M else N | μ | ⊢μ | pc —→ prot[ ℓ ] M | μ

-------------------------------------------------------------------- IfFalse
  if (false of ℓ) then M else N | μ | ⊢μ | pc —→ prot[ ℓ ] N | μ

                   Value V    Active (A ⇒ B)
------------------------------------------------------------- Cast
  V ⟨ A ⇒ B ⟩ | μ | ⊢μ | pc —→ applyCast V (A ⇒ B)


Note: function casts and reference casts are inert
                   Value V    Value W
----------------------------------------------------------------------------------- FunCast
  (V ⟨ [ gc₁ ] A → B of g₁ ⇒ [ gc₂ ] C → D of g₂ @ p ⟩) · W | μ | ⊢μ | pc —→
  (V · (W ⟨ C ⇒ A @ p ⟩)) ⟨ stamp B g₁ ⇒ stamp D g₂ @ p ⟩ | μ

Note: why the co-domain cast is not ⟨ B ⇒ D ⟩:
⊢ V : [ gc₁ ] A → B of g₁
⊢ W : C
⊢ W ⟨ C ⇒ A @ p ⟩ : A
⊢ V · (W ⟨ C ⇒ A @ p ⟩) : stamp B g₁

                   Value V
---------------------------------------------------------------- DerefCast
  ! (V ⟨ Ref A of g₁ ⇒ Ref B of g₂ @ p ⟩) | μ | ⊢μ | pc —→
  (! V) ⟨ stamp A g₁ ⇒ stamp B g₂ @ p ⟩ | μ

                   Value V    Value W
----------------------------------------------------------------------- AssignCast
  V ⟨ Ref A of g₁ ⇒ Ref B of g₂ @ p ⟩ := W # tag | μ | ⊢μ | pc —→
  V := (W ⟨ B ⇒ A @ p ⟩) # tag | μ
